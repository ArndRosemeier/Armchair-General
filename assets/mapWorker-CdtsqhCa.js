var te=Object.defineProperty;var ne=(I,E,G)=>E in I?te(I,E,{enumerable:!0,configurable:!0,writable:!0,value:G}):I[E]=G;var A=(I,E,G)=>ne(I,typeof E!="symbol"?E+"":E,G);(function(){"use strict";class I{constructor(e=[]){A(this,"countries");this.countries=e}}const E=Math.sqrt(3),G=.5*(E-1),F=(3-E)/6,W=l=>Math.floor(l)|0,H=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);function U(l=Math.random){const e=T(l),n=new Float64Array(e).map(r=>H[r%12*2]),t=new Float64Array(e).map(r=>H[r%12*2+1]);return function(o,s){let h=0,u=0,g=0;const a=(o+s)*G,f=W(o+a),m=W(s+a),x=(f+m)*F,y=f-x,d=m-x,S=o-y,p=s-d;let w,i;S>p?(w=1,i=0):(w=0,i=1);const c=S-w+F,b=p-i+F,k=S-1+2*F,z=p-1+2*F,B=f&255,v=m&255;let C=.5-S*S-p*p;if(C>=0){const $=B+e[v],L=n[$],O=t[$];C*=C,h=C*C*(L*S+O*p)}let M=.5-c*c-b*b;if(M>=0){const $=B+w+e[v+i],L=n[$],O=t[$];M*=M,u=M*M*(L*c+O*b)}let q=.5-k*k-z*z;if(q>=0){const $=B+1+e[v+1],L=n[$],O=t[$];q*=q,g=q*q*(L*k+O*z)}return 70*(h+u+g)}}function T(l){const n=new Uint8Array(512);for(let t=0;t<512/2;t++)n[t]=t;for(let t=0;t<512/2-1;t++){const r=t+~~(l()*(256-t)),o=n[t];n[t]=n[r],n[r]=o}for(let t=256;t<512;t++)n[t]=n[t-256];return n}function Y(l,e,n,t=1e3){var g;const r=l.length,o=((g=l[0])==null?void 0:g.length)||0,s=Array.from({length:r},()=>Array(o).fill(!1)),h=[[1,0],[-1,0],[0,1],[0,-1]],u=l.map(a=>a.slice());for(let a=0;a<r;a++)for(let f=0;f<o;f++)if(!s[a][f]&&l[a][f]===n){const m=[[a,f]],x=[[a,f]];for(s[a][f]=!0;m.length;){const[y,d]=m.shift();for(const[S,p]of h){const w=y+S,i=d+p;w>=0&&w<r&&i>=0&&i<o&&!s[w][i]&&l[w][i]===n&&(s[w][i]=!0,m.push([w,i]),x.push([w,i]))}}if(x.length<t)for(const[y,d]of x)u[y][d]=e}return u}function P(l,e,n){var g;const t=l.length,r=((g=l[0])==null?void 0:g.length)||0,o=Array.from({length:t},()=>Array(r).fill(!1)),s=[];for(let a=0;a<r;a++)l[0][a]===e&&(s.push([0,a]),o[0][a]=!0),l[t-1][a]===e&&(s.push([t-1,a]),o[t-1][a]=!0);for(let a=1;a<t-1;a++)l[a][0]===e&&(s.push([a,0]),o[a][0]=!0),l[a][r-1]===e&&(s.push([a,r-1]),o[a][r-1]=!0);const h=[[1,0],[-1,0],[0,1],[0,-1]];for(;s.length;){const[a,f]=s.shift();for(const[m,x]of h){const y=a+m,d=f+x;y>=0&&y<t&&d>=0&&d<r&&!o[y][d]&&l[y][d]===e&&(o[y][d]=!0,s.push([y,d]))}}return l.map((a,f)=>a.map((m,x)=>m===e&&!o[f][x]?n:m))}function J(l,e){return _(l,e,{scale:.0018,threshold:-.05,borderStrength:.5,borderWidth:.15,octaves:6,persistence:.5,seed:Math.floor(Math.random()*1e9)})}function _(l,e,n){const t=(n==null?void 0:n.scale)??.015,r=(n==null?void 0:n.threshold)??0,o=(n==null?void 0:n.seed)!==void 0?X(n.seed):Math.random,s=U(o),h=(n==null?void 0:n.borderStrength)??.5,u=(n==null?void 0:n.borderWidth)??.2,g=(n==null?void 0:n.octaves)??4,a=(n==null?void 0:n.persistence)??.5,f=[];for(let x=0;x<e;x++){const y=[];for(let d=0;d<l;d++){const S=d-l/2,p=x-e/2;let w=0,i=0,c=1,b=1;for(let C=0;C<g;C++)w+=s(S*t*c,p*t*c)*b,i+=b,b*=a,c*=2;w/=i;const k=Math.min(d,l-1-d)/(l/2),z=Math.min(x,e-1-x)/(e/2),B=Math.min(k,z);let v=w;if(B<u){const C=h*(1-B/u);v=w*(1-C)+D*C}y.push(v>r?N:D)}f.push(y)}let m=P(f,D,N);return m=Y(m,D,N,1e3),m}function X(l){return function(){let e=l+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}class Q{constructor(e,n=null,t=0,r=0){A(this,"name");A(this,"owner");A(this,"armies");A(this,"income");A(this,"coordinates");A(this,"border");A(this,"oceanBorder");A(this,"neighbors");A(this,"color");A(this,"fortified",!1);A(this,"_center",null);this.name=e,this.owner=n,this.armies=t,this.income=r,this.coordinates=[],this.border=[],this.oceanBorder=[],this.neighbors=[],this.color=[Math.floor(80+Math.random()*150),Math.floor(80+Math.random()*150),Math.floor(80+Math.random()*150)]}setOwner(e){this.owner=e}setArmies(e){this.armies=e}center(){if(this._center)return this._center;if(!this.coordinates.length)return this._center=[0,0],this._center;let e=0,n=0;for(const[t,r]of this.coordinates)e+=t,n+=r;return this._center=[e/this.coordinates.length,n/this.coordinates.length],this._center}canBeFortified(){if(this.fortified)return!1;if(this.owner){for(const[e,n]of this.owner.plannedFortifications)if(e===this)return!1}return!0}}class Z{static generateCountriesMap(e,n={}){if(!e||e.length===0||!e[0])throw new Error("continentMap must be a non-empty 2D array");const t=e.length,r=e[0].length,o=n.countryCount??12,s=n.scale??.09,h=n.minResistance??10,u=n.maxResistance??50,g=n.skipProbability??.9,a=n.seed!==void 0?V(n.seed):Math.random,f=U(a),m=[];for(let i=0;i<t;i++){const c=[];for(let b=0;b<r;b++)c.push(e[i][b]===N?h+(u-h)*Math.abs(f(b*s,i*s)):1/0);m.push(c)}const x=[],y=[];for(let i=0;i<t;i++)for(let c=0;c<r;c++)e[i][c]===N&&y.push([c,i]);for(let i=0;i<o&&y.length>0;i++){const c=Math.floor(a()*y.length),[b,k]=y.splice(c,1)[0];x.push({x:b,y:k,idx:i})}for(let i=0;i<t;i++)for(let c=0;c<r;c++)e[i][c]!==D&&(e[i][c]=N);for(const{x:i,y:c,idx:b}of x)e[c][i]=b;const d=x.map(({x:i,y:c,idx:b})=>[i,c,b]),S=(h+u)/2;for(;d.length>0;){const i=Math.floor(a()*d.length),[c,b,k]=d.splice(i,1)[0],z=[];for(const[B,v]of[[1,0],[0,1],[-1,0],[0,-1]]){const C=c+B,M=b+v;C>=0&&C<r&&M>=0&&M<t&&e[M][C]===N&&z.push([C,M])}if(z.length!==0)for(const[B,v]of z)m[v][B]>S&&a()<g||(e[v][B]=k,d.push([B,v,k]))}const p=Array.from({length:t},()=>Array(r).fill(!1));let w=0;for(let i=0;i<t;i++)for(let c=0;c<r;c++)e[i][c]>=0&&e[i][c]+1>w&&(w=e[i][c]+1);for(let i=0;i<t;i++)for(let c=0;c<r;c++)if(e[i][c]===N&&!p[i][c]){const b=[[c,i]];for(p[i][c]=!0;b.length>0;){const[k,z]=b.pop();e[z][k]=w;for(const[B,v]of[[1,0],[0,1],[-1,0],[0,-1]]){const C=k+B,M=z+v;C>=0&&C<r&&M>=0&&M<t&&e[M][C]===N&&!p[M][C]&&(b.push([C,M]),p[M][C]=!0)}}w++}return e}static generateCountriesInternal(e,n){const t=this.generateCountriesMap(e,n);if(!t||t.length===0||!t[0])throw new Error("map must be a non-empty 2D array");const r=t.length,o=t[0].length,s={};for(let g=0;g<r;g++)for(let a=0;a<o;a++){const f=t[g][a];if(f>=0){if(!s[f]){const m=new Q(`Country ${f}`);m.id=f,s[f]=m}s[f].coordinates.push([a,g])}}const h=Math.max(...Object.keys(s).map(Number)),u=Array.from({length:h+1},(g,a)=>s[a]);return this.findCountryBorders(t,u,o,r),{map:t,countries:u}}static findCountryBorders(e,n,t,r){const o=[[1,0],[0,1],[-1,0],[0,-1]];for(const s of n){const h=s.id;s.border=[],s.oceanBorder=[];for(const[u,g]of s.coordinates){let a=!1,f=!1;for(const[m,x]of o){const y=u+m,d=g+x;(y<0||y>=t||d<0||d>=r||e[d][y]!==h)&&(a=!0,(y<0||y>=t||d<0||d>=r||e[d][y]===D)&&(f=!0))}a&&s.border.push([u,g]),f&&s.oceanBorder.push([u,g])}}}static findNeighbors(e){const n=new Map;for(const t of e)for(const[r,o]of t.border)n.set(`${r},${o}`,t);for(const t of e){const r=new Set;for(const[o,s]of t.border)for(const[h,u]of[[1,0],[0,1],[-1,0],[0,-1]]){const g=o+h,a=s+u,f=n.get(`${g},${a}`);f&&f!==t&&r.add(f)}t.neighbors=Array.from(r)}}static mergeSmallCountries(e,n=1e3){let t=!0;for(;t;){t=!1;for(let r=e.length-1;r>=0;r--){const o=e[r];if(o.coordinates.length<n&&o.neighbors.length>0){let s=o.neighbors[0];for(const h of o.neighbors)h.coordinates.length<s.coordinates.length&&(s=h);s.coordinates.push(...o.coordinates),e.splice(r,1),t=!0}}t&&this.findNeighbors(e)}}static generateCountries(e,n={}){const{map:t,countries:r}=this.generateCountriesInternal(e,n);this.findNeighbors(r);const o=(n==null?void 0:n.minCountrySize)??1e3;if(this.mergeSmallCountries(r,o),!t||t.length===0||!t[0])throw new Error("map must be a non-empty 2D array");const s=t[0].length,h=t.length;return this.findCountryBorders(t,r,s,h),this.findNeighbors(r),{map:t,countries:r}}}function V(l){return function(){let e=l+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}function ee(l,e){return Z.generateCountries(l,{countryCount:e,minResistance:0,maxResistance:130,skipProbability:0})}const D=-1,N=-2,R=class R{constructor(e,n,t=[]){A(this,"countries");A(this,"map");A(this,"continents",[]);this.countries=t,this.map=R.createOceanMap(e,n)}static logCountryNamesInOrder(e,n=""){const t=e.map((r,o)=>`${o}: ${r.name}`);console.log(`[WorldMap] Country order${n?" - "+n:""}:
`+t.join(", "))}static checkMapCountryConsistency(e,n){if(!Array.isArray(e)||!Array.isArray(n))return console.error("[WorldMap] Consistency check failed: map or countries not arrays"),!1;let t=!0;for(let r=0;r<e.length;++r)for(let o=0;o<e[r].length;++o){const s=e[r][o];s>=0&&(n[s]?typeof n[s].name!="string"&&(console.error(`[WorldMap] Inconsistent: countries[${s}] has no valid name at map[${r}][${o}]`),t=!1):(console.error(`[WorldMap] Inconsistent: map[${r}][${o}] = ${s}, but countries[${s}] is undefined`),t=!1))}return t}assignRandomCountryNames(){let e=!1;for(;!e;){const n=new Set;for(const t of this.countries){let r,o=0;do if(r=R.generateRandomName(),o++,o>1e3)throw new Error("Failed to generate unique random country names");while(n.has(r));t.name=r,n.add(r)}e=n.size===this.countries.length}}assignRealCountryNames(){let e=!1;for(;!e;){const n=[...R.REAL_COUNTRY_NAMES],t=new Set;for(const r of this.countries){let o;if(n.length>0){const s=Math.floor(Math.random()*n.length);o=n.splice(s,1)[0]}else{let s=0;do if(o=R.generateRandomName(),s++,s>1e3)throw new Error("Failed to generate unique fallback country names");while(t.has(o))}r.name=o,t.add(o)}e=t.size===this.countries.length}}static generateRandomName(){const e=["zan","mor","vek","tal","rin","dor","lek","sha","val","nor","ka","bel","dra","sil","tur","gar","fen","mir","sol","vor","lin","sar","qu","zel","ron","bar","zen","tir","lom","kal","vin","lor","mel","dar","gol","han","jor","ken","lun","mar"],n=2+Math.floor(Math.random()*2);let t="";for(let r=0;r<n;r++)t+=e[Math.floor(Math.random()*e.length)];return t.charAt(0).toUpperCase()+t.slice(1)}static createOceanMap(e,n){return Array.from({length:n},()=>Array(e).fill(D))}static generateContinentsMap(e,n,t){return _(e,n,t)}static createMap(e,n,t=40,r=!0){const o=J(e,n),{map:s,countries:h}=ee(o,t),u=new R(e,n,h);return u.map=s,r?u.assignRealCountryNames():u.assignRandomCountryNames(),u.regenerateMapFromCountries(u.countries),u.createContinents(),u}addCountry(e){this.countries.push(e)}createContinents(){const e=new Set,n=[];for(const t of this.countries)if(!e.has(t)){const r=[t],o=[];for(e.add(t);r.length>0;){const s=r.shift();o.push(s);for(const h of s.neighbors)e.has(h)||(e.add(h),r.push(h))}n.push(new I(o))}this.continents=n}getCountries(){return this.countries}distance(e,n){const[t,r]=e.center(),[o,s]=n.center(),h=Math.sqrt((t-o)**2+(r-s)**2);if(e.neighbors.includes(n)||n.neighbors.includes(e))return h;const u=e.oceanBorder&&e.oceanBorder.length>0,g=n.oceanBorder&&n.oceanBorder.length>0;return u&&g?h*3:null}getMap(){return this.map}regenerateMapFromCountries(e){if(!this.map||!Array.isArray(this.map)||this.map.length===0||this.map[0].length===0)throw new Error("WorldMap.map is not initialized or has invalid dimensions");const n=this.map.length,t=this.map[0].length,r=R.createOceanMap(t,n);for(let o=0;o<e.length;++o){const s=e[o];if(!s.coordinates||!Array.isArray(s.coordinates))throw new Error(`Country at index ${o} has no valid coordinates array`);for(const[h,u]of s.coordinates){if(typeof h!="number"||typeof u!="number"||h<0||h>=t||u<0||u>=n)throw new Error(`Country index ${o} has out-of-bounds coordinate (${h}, ${u})`);r[u][h]=o}}this.map=r}};A(R,"REAL_COUNTRY_NAMES",["Afghanistan","Albania","Algeria","Andorra","Angola","Argentina","Armenia","Australia","Austria","Azerbaijan","Bahamas","Bahrain","Bangladesh","Barbados","Belarus","Belgium","Belize","Benin","Bhutan","Bolivia","Bosnia and Herzegovina","Botswana","Brazil","Brunei","Bulgaria","Burkina Faso","Burundi","Cabo Verde","Cambodia","Cameroon","Canada","Central African Republic","Chad","Chile","China","Colombia","Comoros","Congo","Costa Rica","Croatia","Cuba","Cyprus","Czechia","Denmark","Djibouti","Dominica","Dominican Republic","Ecuador","Egypt","El Salvador","Equatorial Guinea","Eritrea","Estonia","Eswatini","Ethiopia","Fiji","Finland","France","Gabon","Gambia","Georgia","Germany","Ghana","Greece","Grenada","Guatemala","Guinea","Guinea-Bissau","Guyana","Haiti","Honduras","Hungary","Iceland","India","Indonesia","Iran","Iraq","Ireland","Israel","Italy","Jamaica","Japan","Jordan","Kazakhstan","Kenya","Kiribati","Kuwait","Kyrgyzstan","Laos","Latvia","Lebanon","Lesotho","Liberia","Libya","Liechtenstein","Lithuania","Luxembourg","Madagascar","Malawi","Malaysia"]);let j=R;const K=self;K.onmessage=async l=>{const e=l.data;if(e.type==="generate"){const n=j.createMap(e.width,e.height,e.countryCount),t=n.getMap(),r=n.getCountries();j.checkMapCountryConsistency(t,r)||console.error("[WorldMap] Consistency check failed in worker before transfer!");const o={map:t,countries:r};K.postMessage({type:"done",result:o})}}})();
