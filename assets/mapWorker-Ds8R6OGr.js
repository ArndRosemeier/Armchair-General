var te=Object.defineProperty;var ne=($,R,D)=>R in $?te($,R,{enumerable:!0,configurable:!0,writable:!0,value:D}):$[R]=D;var M=($,R,D)=>ne($,typeof R!="symbol"?R+"":R,D);(function(){"use strict";class ${constructor(e=[]){M(this,"countries");this.countries=e}}const R=Math.sqrt(3),D=.5*(R-1),G=(3-R)/6,j=u=>Math.floor(u)|0,W=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);function H(u=Math.random){const e=K(u),t=new Float64Array(e).map(r=>W[r%12*2]),n=new Float64Array(e).map(r=>W[r%12*2+1]);return function(o,s){let l=0,c=0,m=0;const i=(o+s)*D,d=j(o+i),y=j(s+i),C=(d+y)*G,g=d-C,f=y-C,S=o-g,A=s-f;let x,a;S>A?(x=1,a=0):(x=0,a=1);const h=S-x+G,b=A-a+G,v=S-1+2*G,N=A-1+2*G,B=d&255,I=y&255;let w=.5-S*S-A*A;if(w>=0){const E=B+e[I],F=t[E],q=n[E];w*=w,l=w*w*(F*S+q*A)}let p=.5-h*h-b*b;if(p>=0){const E=B+x+e[I+a],F=t[E],q=n[E];p*=p,c=p*p*(F*h+q*b)}let P=.5-v*v-N*N;if(P>=0){const E=B+1+e[I+1],F=t[E],q=n[E];P*=P,m=P*P*(F*v+q*N)}return 70*(l+c+m)}}function K(u){const t=new Uint8Array(512);for(let n=0;n<512/2;n++)t[n]=n;for(let n=0;n<512/2-1;n++){const r=n+~~(u()*(256-n)),o=t[n];t[n]=t[r],t[r]=o}for(let n=256;n<512;n++)t[n]=t[n-256];return t}function T(u,e,t,n=1e3){var m;const r=u.length,o=((m=u[0])==null?void 0:m.length)||0,s=Array.from({length:r},()=>Array(o).fill(!1)),l=[[1,0],[-1,0],[0,1],[0,-1]],c=u.map(i=>i.slice());for(let i=0;i<r;i++)for(let d=0;d<o;d++)if(!s[i][d]&&u[i][d]===t){const y=[[i,d]],C=[[i,d]];for(s[i][d]=!0;y.length;){const[g,f]=y.shift();for(const[S,A]of l){const x=g+S,a=f+A;x>=0&&x<r&&a>=0&&a<o&&!s[x][a]&&u[x][a]===t&&(s[x][a]=!0,y.push([x,a]),C.push([x,a]))}}if(C.length<n)for(const[g,f]of C)c[g][f]=e}return c}function Y(u,e,t){var m;const n=u.length,r=((m=u[0])==null?void 0:m.length)||0,o=Array.from({length:n},()=>Array(r).fill(!1)),s=[];for(let i=0;i<r;i++)u[0][i]===e&&(s.push([0,i]),o[0][i]=!0),u[n-1][i]===e&&(s.push([n-1,i]),o[n-1][i]=!0);for(let i=1;i<n-1;i++)u[i][0]===e&&(s.push([i,0]),o[i][0]=!0),u[i][r-1]===e&&(s.push([i,r-1]),o[i][r-1]=!0);const l=[[1,0],[-1,0],[0,1],[0,-1]];for(;s.length;){const[i,d]=s.shift();for(const[y,C]of l){const g=i+y,f=d+C;g>=0&&g<n&&f>=0&&f<r&&!o[g][f]&&u[g][f]===e&&(o[g][f]=!0,s.push([g,f]))}}return u.map((i,d)=>i.map((y,C)=>y===e&&!o[d][C]?t:y))}function X(u,e){return U(u,e,{scale:.0018,threshold:-.05,borderStrength:.5,borderWidth:.15,octaves:6,persistence:.5,seed:Math.floor(Math.random()*1e9)})}function U(u,e,t){const n=(t==null?void 0:t.scale)??.015,r=(t==null?void 0:t.threshold)??0,o=(t==null?void 0:t.seed)!==void 0?Q(t.seed):Math.random,s=H(o),l=(t==null?void 0:t.borderStrength)??.5,c=(t==null?void 0:t.borderWidth)??.2,m=(t==null?void 0:t.octaves)??4,i=(t==null?void 0:t.persistence)??.5,d=[];for(let C=0;C<e;C++){const g=[];for(let f=0;f<u;f++){const S=f-u/2,A=C-e/2;let x=0,a=0,h=1,b=1;for(let w=0;w<m;w++)x+=s(S*n*h,A*n*h)*b,a+=b,b*=i,h*=2;x/=a;const v=Math.min(f,u-1-f)/(u/2),N=Math.min(C,e-1-C)/(e/2),B=Math.min(v,N);let I=x;if(B<c){const w=l*(1-B/c);I=x*(1-w)+L*w}g.push(I>r?k:L)}d.push(g)}let y=Y(d,L,k);return y=T(y,L,k,1e3),y}function Q(u){return function(){let e=u+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}class O{constructor(e,t=null,n=0,r=0){M(this,"name");M(this,"owner");M(this,"armies");M(this,"income");M(this,"IncomePotential");M(this,"coordinates");M(this,"border");M(this,"oceanBorder");M(this,"neighbors");M(this,"color");M(this,"fortified",!1);M(this,"nationalPride");M(this,"unrestLevel",0);M(this,"_center",null);this.name=e,this.owner=t,this.armies=n,this.income=r;const o=1+9*Math.pow(Math.random(),3);this.IncomePotential=Math.floor(this.income*o/1e3)*1e3,this.coordinates=[],this.border=[],this.oceanBorder=[],this.neighbors=[],this.color=[Math.floor(80+Math.random()*150),Math.floor(80+Math.random()*150),Math.floor(80+Math.random()*150)];const s=1e3,l=1e5,c=Math.random()*Math.random();this.nationalPride=Math.floor(s+(l-s)*c),this.unrestLevel=0}setOwner(e){this.owner=e}setArmies(e){this.armies=e}center(){if(this._center)return this._center;if(!this.coordinates.length)return this._center=[0,0],this._center;let e=0,t=0;for(const[n,r]of this.coordinates)e+=n,t+=r;return this._center=[e/this.coordinates.length,t/this.coordinates.length],this._center}canBeFortified(){if(this.fortified)return!1;if(this.owner){for(const[e,t]of this.owner.plannedFortifications)if(e===this)return!1}return!0}toJSON(){return{id:this.name,name:this.name,ownerId:this.owner?this.owner.name:null,armies:this.armies,income:this.income,coordinates:this.coordinates,border:this.border,oceanBorder:this.oceanBorder,neighborIds:this.neighbors.map(e=>e.name),color:this.color,fortified:this.fortified,nationalPride:this.nationalPride,unrestLevel:this.unrestLevel}}static fromJSON(e,t,n){const r=new O(e.name,null,e.armies,e.income);return r.coordinates=e.coordinates,r.border=e.border,r.oceanBorder=e.oceanBorder,r.color=e.color,r.fortified=e.fortified,r.nationalPride=e.nationalPride??1e3,r.unrestLevel=e.unrestLevel??0,r._ownerId=e.ownerId,r._neighborIds=e.neighborIds,n[e.name]=r,r}resolveReferences(e,t){this.owner=this._ownerId?e[this._ownerId]:null,this.neighbors=(this._neighborIds||[]).map(n=>t[n]).filter(Boolean),delete this._ownerId,delete this._neighborIds}static calculateIncomePotential(e){const t=1+9*Math.pow(Math.random(),3);return Math.floor(e*t/1e3)*1e3}recalculateIncomePotential(){this.IncomePotential=O.calculateIncomePotential(this.income)}}class Z{static generateCountriesMap(e,t={}){if(!e||e.length===0||!e[0])throw new Error("continentMap must be a non-empty 2D array");const n=e.length,r=e[0].length,o=t.countryCount??12,s=t.scale??.09,l=t.minResistance??10,c=t.maxResistance??50,m=t.skipProbability??.9,i=t.seed!==void 0?V(t.seed):Math.random,d=H(i),y=[];for(let a=0;a<n;a++){const h=[];for(let b=0;b<r;b++)h.push(e[a][b]===k?l+(c-l)*Math.abs(d(b*s,a*s)):1/0);y.push(h)}const C=[],g=[];for(let a=0;a<n;a++)for(let h=0;h<r;h++)e[a][h]===k&&g.push([h,a]);for(let a=0;a<o&&g.length>0;a++){const h=Math.floor(i()*g.length),[b,v]=g.splice(h,1)[0];C.push({x:b,y:v,idx:a})}for(let a=0;a<n;a++)for(let h=0;h<r;h++)e[a][h]!==L&&(e[a][h]=k);for(const{x:a,y:h,idx:b}of C)e[h][a]=b;const f=C.map(({x:a,y:h,idx:b})=>[a,h,b]),S=(l+c)/2;for(;f.length>0;){const a=Math.floor(i()*f.length),[h,b,v]=f.splice(a,1)[0],N=[];for(const[B,I]of[[1,0],[0,1],[-1,0],[0,-1]]){const w=h+B,p=b+I;w>=0&&w<r&&p>=0&&p<n&&e[p][w]===k&&N.push([w,p])}if(N.length!==0)for(const[B,I]of N)y[I][B]>S&&i()<m||(e[I][B]=v,f.push([B,I,v]))}const A=Array.from({length:n},()=>Array(r).fill(!1));let x=0;for(let a=0;a<n;a++)for(let h=0;h<r;h++)e[a][h]>=0&&e[a][h]+1>x&&(x=e[a][h]+1);for(let a=0;a<n;a++)for(let h=0;h<r;h++)if(e[a][h]===k&&!A[a][h]){const b=[[h,a]];for(A[a][h]=!0;b.length>0;){const[v,N]=b.pop();e[N][v]=x;for(const[B,I]of[[1,0],[0,1],[-1,0],[0,-1]]){const w=v+B,p=N+I;w>=0&&w<r&&p>=0&&p<n&&e[p][w]===k&&!A[p][w]&&(b.push([w,p]),A[p][w]=!0)}}x++}return e}static generateCountriesInternal(e,t){const n=this.generateCountriesMap(e,t);if(!n||n.length===0||!n[0])throw new Error("map must be a non-empty 2D array");const r=n.length,o=n[0].length,s={};for(let m=0;m<r;m++)for(let i=0;i<o;i++){const d=n[m][i];if(d>=0){if(!s[d]){const y=new O(`Country ${d}`);y.id=d,s[d]=y}s[d].coordinates.push([i,m])}}const l=Math.max(...Object.keys(s).map(Number)),c=Array.from({length:l+1},(m,i)=>s[i]);return this.findCountryBorders(n,c,o,r),{map:n,countries:c}}static findCountryBorders(e,t,n,r){const o=[[1,0],[0,1],[-1,0],[0,-1]];for(const s of t){const l=s.id;s.border=[],s.oceanBorder=[];for(const[c,m]of s.coordinates){let i=!1,d=!1;for(const[y,C]of o){const g=c+y,f=m+C;(g<0||g>=n||f<0||f>=r||e[f][g]!==l)&&(i=!0,(g<0||g>=n||f<0||f>=r||e[f][g]===L)&&(d=!0))}i&&s.border.push([c,m]),d&&s.oceanBorder.push([c,m])}}}static findNeighbors(e){const t=new Map;for(const n of e)for(const[r,o]of n.border)t.set(`${r},${o}`,n);for(const n of e){const r=new Set;for(const[o,s]of n.border)for(const[l,c]of[[1,0],[0,1],[-1,0],[0,-1]]){const m=o+l,i=s+c,d=t.get(`${m},${i}`);d&&d!==n&&r.add(d)}n.neighbors=Array.from(r)}}static mergeSmallCountries(e,t=1e3,n){let r=!0;for(;r;){r=!1;for(let o=e.length-1;o>=0;o--){const s=e[o];if(s.coordinates.length<t&&s.neighbors.length>0){let l=s.neighbors[0];for(const c of s.neighbors)c.coordinates.length<l.coordinates.length&&(l=c);if(l.coordinates.push(...s.coordinates),n&&l.id!==void 0&&s.id!==void 0)for(const[c,m]of s.coordinates)n[m][c]=l.id;e.splice(o,1),r=!0}}r&&(this.findNeighbors(e),console.log("Merged countries"))}}static generateCountries(e,t={}){const{map:n,countries:r}=this.generateCountriesInternal(e,t);this.findNeighbors(r);const o=(t==null?void 0:t.minCountrySize)??1e3;if(this.mergeSmallCountries(r,o,n),!n||n.length===0||!n[0])throw new Error("map must be a non-empty 2D array");const s=n[0].length,l=n.length;return this.findCountryBorders(n,r,s,l),this.findNeighbors(r),{map:n,countries:r}}}function V(u){return function(){let e=u+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}function ee(u,e){return Z.generateCountries(u,{countryCount:e,minResistance:0,maxResistance:130,skipProbability:0})}const L=-1,k=-2,z=class z{constructor(e,t,n=[]){M(this,"countries");M(this,"map");M(this,"continents",[]);this.countries=n,this.map=z.createOceanMap(e,t)}static logCountryNamesInOrder(e,t=""){const n=e.map((r,o)=>`${o}: ${r.name}`);console.log(`[WorldMap] Country order${t?" - "+t:""}:
`+n.join(", "))}static checkMapCountryConsistency(e,t){if(!Array.isArray(e)||!Array.isArray(t))return console.error("[WorldMap] Consistency check failed: map or countries not arrays"),!1;let n=!0;for(let r=0;r<e.length;++r)for(let o=0;o<e[r].length;++o){const s=e[r][o];s>=0&&(t[s]?typeof t[s].name!="string"&&(console.error(`[WorldMap] Inconsistent: countries[${s}] has no valid name at map[${r}][${o}]`),n=!1):(console.error(`[WorldMap] Inconsistent: map[${r}][${o}] = ${s}, but countries[${s}] is undefined`),n=!1))}return n}assignRandomCountryNames(){let e=!1;for(;!e;){const t=new Set;for(const n of this.countries){let r,o=0;do if(r=z.generateRandomName(),o++,o>1e3)throw new Error("Failed to generate unique random country names");while(t.has(r));n.name=r,t.add(r)}e=t.size===this.countries.length}}assignRealCountryNames(){let e=!1;for(;!e;){const t=[...z.REAL_COUNTRY_NAMES],n=new Set;for(const r of this.countries){let o;if(t.length>0){const s=Math.floor(Math.random()*t.length);o=t.splice(s,1)[0]}else{let s=0;do if(o=z.generateRandomName(),s++,s>1e3)throw new Error("Failed to generate unique fallback country names");while(n.has(o))}r.name=o,n.add(o)}e=n.size===this.countries.length}}static generateRandomName(){const e=["zan","mor","vek","tal","rin","dor","lek","sha","val","nor","ka","bel","dra","sil","tur","gar","fen","mir","sol","vor","lin","sar","qu","zel","ron","bar","zen","tir","lom","kal","vin","lor","mel","dar","gol","han","jor","ken","lun","mar"],t=2+Math.floor(Math.random()*2);let n="";for(let r=0;r<t;r++)n+=e[Math.floor(Math.random()*e.length)];return n.charAt(0).toUpperCase()+n.slice(1)}static createOceanMap(e,t){return Array.from({length:t},()=>Array(e).fill(L))}static generateContinentsMap(e,t,n){return U(e,t,n)}static createMap(e,t,n=40,r=!0){const o=X(e,t),{map:s,countries:l}=ee(o,n),c=new z(e,t,l);return c.map=s,r?c.assignRealCountryNames():c.assignRandomCountryNames(),c.regenerateMapFromCountries(c.countries),c.createContinents(),c}addCountry(e){this.countries.push(e)}createContinents(){const e=new Set,t=[];for(const n of this.countries)if(!e.has(n)){const r=[n],o=[];for(e.add(n);r.length>0;){const s=r.shift();o.push(s);for(const l of s.neighbors)e.has(l)||(e.add(l),r.push(l))}t.push(new $(o))}this.continents=t}getCountries(){return this.countries}distance(e,t){const[n,r]=e.center(),[o,s]=t.center(),l=Math.sqrt((n-o)**2+(r-s)**2);if(e.neighbors.includes(t)||t.neighbors.includes(e))return l;const c=e.oceanBorder&&e.oceanBorder.length>0,m=t.oceanBorder&&t.oceanBorder.length>0;return c&&m?l*3:null}getMap(){return this.map}regenerateMapFromCountries(e){if(!this.map||!Array.isArray(this.map)||this.map.length===0||this.map[0].length===0)throw new Error("WorldMap.map is not initialized or has invalid dimensions");const t=this.map.length,n=this.map[0].length,r=z.createOceanMap(n,t);for(let o=0;o<e.length;++o){const s=e[o];if(!s.coordinates||!Array.isArray(s.coordinates))throw new Error(`Country at index ${o} has no valid coordinates array`);for(const[l,c]of s.coordinates){if(typeof l!="number"||typeof c!="number"||l<0||l>=n||c<0||c>=t)throw new Error(`Country index ${o} has out-of-bounds coordinate (${l}, ${c})`);r[c][l]=o}}this.map=r}};M(z,"REAL_COUNTRY_NAMES",["Afghanistan","Albania","Algeria","Andorra","Angola","Argentina","Armenia","Australia","Austria","Azerbaijan","Bahamas","Bahrain","Bangladesh","Barbados","Belarus","Belgium","Belize","Benin","Bhutan","Bolivia","Bosnia and Herzegovina","Botswana","Brazil","Brunei","Bulgaria","Burkina Faso","Burundi","Cabo Verde","Cambodia","Cameroon","Canada","Central African Republic","Chad","Chile","China","Colombia","Comoros","Congo","Costa Rica","Croatia","Cuba","Cyprus","Czechia","Denmark","Djibouti","Dominica","Dominican Republic","Ecuador","Egypt","El Salvador","Equatorial Guinea","Eritrea","Estonia","Eswatini","Ethiopia","Fiji","Finland","France","Gabon","Gambia","Georgia","Germany","Ghana","Greece","Grenada","Guatemala","Guinea","Guinea-Bissau","Guyana","Haiti","Honduras","Hungary","Iceland","India","Indonesia","Iran","Iraq","Ireland","Israel","Italy","Jamaica","Japan","Jordan","Kazakhstan","Kenya","Kiribati","Kuwait","Kyrgyzstan","Laos","Latvia","Lebanon","Lesotho","Liberia","Libya","Liechtenstein","Lithuania","Luxembourg","Madagascar","Malawi","Malaysia"]);let _=z;const J=self;J.onmessage=async u=>{const e=u.data;if(e.type==="generate"){const t=_.createMap(e.width,e.height,e.countryCount),n=t.getMap(),r=t.getCountries();_.checkMapCountryConsistency(n,r)||console.error("[WorldMap] Consistency check failed in worker before transfer!");const o={map:n,countries:r};J.postMessage({type:"done",result:o})}}})();
