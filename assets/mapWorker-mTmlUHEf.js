var te=Object.defineProperty;var ne=($,R,G)=>R in $?te($,R,{enumerable:!0,configurable:!0,writable:!0,value:G}):$[R]=G;var p=($,R,G)=>ne($,typeof R!="symbol"?R+"":R,G);(function(){"use strict";class ${constructor(e=[]){p(this,"countries");this.countries=e}}const R=Math.sqrt(3),G=.5*(R-1),F=(3-R)/6,W=h=>Math.floor(h)|0,H=new Float64Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);function U(h=Math.random){const e=T(h),n=new Float64Array(e).map(r=>H[r%12*2]),t=new Float64Array(e).map(r=>H[r%12*2+1]);return function(o,s){let l=0,u=0,g=0;const i=(o+s)*G,f=W(o+i),y=W(s+i),w=(f+y)*F,m=f-w,d=y-w,S=o-m,A=s-d;let x,a;S>A?(x=1,a=0):(x=0,a=1);const c=S-x+F,b=A-a+F,v=S-1+2*F,N=A-1+2*F,B=f&255,I=y&255;let C=.5-S*S-A*A;if(C>=0){const E=B+e[I],O=n[E],L=t[E];C*=C,l=C*C*(O*S+L*A)}let M=.5-c*c-b*b;if(M>=0){const E=B+x+e[I+a],O=n[E],L=t[E];M*=M,u=M*M*(O*c+L*b)}let q=.5-v*v-N*N;if(q>=0){const E=B+1+e[I+1],O=n[E],L=t[E];q*=q,g=q*q*(O*v+L*N)}return 70*(l+u+g)}}function T(h){const n=new Uint8Array(512);for(let t=0;t<512/2;t++)n[t]=t;for(let t=0;t<512/2-1;t++){const r=t+~~(h()*(256-t)),o=n[t];n[t]=n[r],n[r]=o}for(let t=256;t<512;t++)n[t]=n[t-256];return n}function Y(h,e,n,t=1e3){var g;const r=h.length,o=((g=h[0])==null?void 0:g.length)||0,s=Array.from({length:r},()=>Array(o).fill(!1)),l=[[1,0],[-1,0],[0,1],[0,-1]],u=h.map(i=>i.slice());for(let i=0;i<r;i++)for(let f=0;f<o;f++)if(!s[i][f]&&h[i][f]===n){const y=[[i,f]],w=[[i,f]];for(s[i][f]=!0;y.length;){const[m,d]=y.shift();for(const[S,A]of l){const x=m+S,a=d+A;x>=0&&x<r&&a>=0&&a<o&&!s[x][a]&&h[x][a]===n&&(s[x][a]=!0,y.push([x,a]),w.push([x,a]))}}if(w.length<t)for(const[m,d]of w)u[m][d]=e}return u}function P(h,e,n){var g;const t=h.length,r=((g=h[0])==null?void 0:g.length)||0,o=Array.from({length:t},()=>Array(r).fill(!1)),s=[];for(let i=0;i<r;i++)h[0][i]===e&&(s.push([0,i]),o[0][i]=!0),h[t-1][i]===e&&(s.push([t-1,i]),o[t-1][i]=!0);for(let i=1;i<t-1;i++)h[i][0]===e&&(s.push([i,0]),o[i][0]=!0),h[i][r-1]===e&&(s.push([i,r-1]),o[i][r-1]=!0);const l=[[1,0],[-1,0],[0,1],[0,-1]];for(;s.length;){const[i,f]=s.shift();for(const[y,w]of l){const m=i+y,d=f+w;m>=0&&m<t&&d>=0&&d<r&&!o[m][d]&&h[m][d]===e&&(o[m][d]=!0,s.push([m,d]))}}return h.map((i,f)=>i.map((y,w)=>y===e&&!o[f][w]?n:y))}function X(h,e){return J(h,e,{scale:.0018,threshold:-.05,borderStrength:.5,borderWidth:.15,octaves:6,persistence:.5,seed:Math.floor(Math.random()*1e9)})}function J(h,e,n){const t=(n==null?void 0:n.scale)??.015,r=(n==null?void 0:n.threshold)??0,o=(n==null?void 0:n.seed)!==void 0?Q(n.seed):Math.random,s=U(o),l=(n==null?void 0:n.borderStrength)??.5,u=(n==null?void 0:n.borderWidth)??.2,g=(n==null?void 0:n.octaves)??4,i=(n==null?void 0:n.persistence)??.5,f=[];for(let w=0;w<e;w++){const m=[];for(let d=0;d<h;d++){const S=d-h/2,A=w-e/2;let x=0,a=0,c=1,b=1;for(let C=0;C<g;C++)x+=s(S*t*c,A*t*c)*b,a+=b,b*=i,c*=2;x/=a;const v=Math.min(d,h-1-d)/(h/2),N=Math.min(w,e-1-w)/(e/2),B=Math.min(v,N);let I=x;if(B<u){const C=l*(1-B/u);I=x*(1-C)+D*C}m.push(I>r?k:D)}f.push(m)}let y=P(f,D,k);return y=Y(y,D,k,1e3),y}function Q(h){return function(){let e=h+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}class j{constructor(e,n=null,t=0,r=0){p(this,"name");p(this,"owner");p(this,"armies");p(this,"income");p(this,"coordinates");p(this,"border");p(this,"oceanBorder");p(this,"neighbors");p(this,"color");p(this,"fortified",!1);p(this,"_center",null);this.name=e,this.owner=n,this.armies=t,this.income=r,this.coordinates=[],this.border=[],this.oceanBorder=[],this.neighbors=[],this.color=[Math.floor(80+Math.random()*150),Math.floor(80+Math.random()*150),Math.floor(80+Math.random()*150)]}setOwner(e){this.owner=e}setArmies(e){this.armies=e}center(){if(this._center)return this._center;if(!this.coordinates.length)return this._center=[0,0],this._center;let e=0,n=0;for(const[t,r]of this.coordinates)e+=t,n+=r;return this._center=[e/this.coordinates.length,n/this.coordinates.length],this._center}canBeFortified(){if(this.fortified)return!1;if(this.owner){for(const[e,n]of this.owner.plannedFortifications)if(e===this)return!1}return!0}toJSON(){return{id:this.name,name:this.name,ownerId:this.owner?this.owner.name:null,armies:this.armies,income:this.income,coordinates:this.coordinates,border:this.border,oceanBorder:this.oceanBorder,neighborIds:this.neighbors.map(e=>e.name),color:this.color,fortified:this.fortified}}static fromJSON(e,n,t){const r=new j(e.name,null,e.armies,e.income);return r.coordinates=e.coordinates,r.border=e.border,r.oceanBorder=e.oceanBorder,r.color=e.color,r.fortified=e.fortified,r._ownerId=e.ownerId,r._neighborIds=e.neighborIds,t[e.name]=r,r}resolveReferences(e,n){this.owner=this._ownerId?e[this._ownerId]:null,this.neighbors=(this._neighborIds||[]).map(t=>n[t]).filter(Boolean),delete this._ownerId,delete this._neighborIds}}class Z{static generateCountriesMap(e,n={}){if(!e||e.length===0||!e[0])throw new Error("continentMap must be a non-empty 2D array");const t=e.length,r=e[0].length,o=n.countryCount??12,s=n.scale??.09,l=n.minResistance??10,u=n.maxResistance??50,g=n.skipProbability??.9,i=n.seed!==void 0?V(n.seed):Math.random,f=U(i),y=[];for(let a=0;a<t;a++){const c=[];for(let b=0;b<r;b++)c.push(e[a][b]===k?l+(u-l)*Math.abs(f(b*s,a*s)):1/0);y.push(c)}const w=[],m=[];for(let a=0;a<t;a++)for(let c=0;c<r;c++)e[a][c]===k&&m.push([c,a]);for(let a=0;a<o&&m.length>0;a++){const c=Math.floor(i()*m.length),[b,v]=m.splice(c,1)[0];w.push({x:b,y:v,idx:a})}for(let a=0;a<t;a++)for(let c=0;c<r;c++)e[a][c]!==D&&(e[a][c]=k);for(const{x:a,y:c,idx:b}of w)e[c][a]=b;const d=w.map(({x:a,y:c,idx:b})=>[a,c,b]),S=(l+u)/2;for(;d.length>0;){const a=Math.floor(i()*d.length),[c,b,v]=d.splice(a,1)[0],N=[];for(const[B,I]of[[1,0],[0,1],[-1,0],[0,-1]]){const C=c+B,M=b+I;C>=0&&C<r&&M>=0&&M<t&&e[M][C]===k&&N.push([C,M])}if(N.length!==0)for(const[B,I]of N)y[I][B]>S&&i()<g||(e[I][B]=v,d.push([B,I,v]))}const A=Array.from({length:t},()=>Array(r).fill(!1));let x=0;for(let a=0;a<t;a++)for(let c=0;c<r;c++)e[a][c]>=0&&e[a][c]+1>x&&(x=e[a][c]+1);for(let a=0;a<t;a++)for(let c=0;c<r;c++)if(e[a][c]===k&&!A[a][c]){const b=[[c,a]];for(A[a][c]=!0;b.length>0;){const[v,N]=b.pop();e[N][v]=x;for(const[B,I]of[[1,0],[0,1],[-1,0],[0,-1]]){const C=v+B,M=N+I;C>=0&&C<r&&M>=0&&M<t&&e[M][C]===k&&!A[M][C]&&(b.push([C,M]),A[M][C]=!0)}}x++}return e}static generateCountriesInternal(e,n){const t=this.generateCountriesMap(e,n);if(!t||t.length===0||!t[0])throw new Error("map must be a non-empty 2D array");const r=t.length,o=t[0].length,s={};for(let g=0;g<r;g++)for(let i=0;i<o;i++){const f=t[g][i];if(f>=0){if(!s[f]){const y=new j(`Country ${f}`);y.id=f,s[f]=y}s[f].coordinates.push([i,g])}}const l=Math.max(...Object.keys(s).map(Number)),u=Array.from({length:l+1},(g,i)=>s[i]);return this.findCountryBorders(t,u,o,r),{map:t,countries:u}}static findCountryBorders(e,n,t,r){const o=[[1,0],[0,1],[-1,0],[0,-1]];for(const s of n){const l=s.id;s.border=[],s.oceanBorder=[];for(const[u,g]of s.coordinates){let i=!1,f=!1;for(const[y,w]of o){const m=u+y,d=g+w;(m<0||m>=t||d<0||d>=r||e[d][m]!==l)&&(i=!0,(m<0||m>=t||d<0||d>=r||e[d][m]===D)&&(f=!0))}i&&s.border.push([u,g]),f&&s.oceanBorder.push([u,g])}}}static findNeighbors(e){const n=new Map;for(const t of e)for(const[r,o]of t.border)n.set(`${r},${o}`,t);for(const t of e){const r=new Set;for(const[o,s]of t.border)for(const[l,u]of[[1,0],[0,1],[-1,0],[0,-1]]){const g=o+l,i=s+u,f=n.get(`${g},${i}`);f&&f!==t&&r.add(f)}t.neighbors=Array.from(r)}}static mergeSmallCountries(e,n=1e3){let t=!0;for(;t;){t=!1;for(let r=e.length-1;r>=0;r--){const o=e[r];if(o.coordinates.length<n&&o.neighbors.length>0){let s=o.neighbors[0];for(const l of o.neighbors)l.coordinates.length<s.coordinates.length&&(s=l);s.coordinates.push(...o.coordinates),e.splice(r,1),t=!0}}t&&this.findNeighbors(e)}}static generateCountries(e,n={}){const{map:t,countries:r}=this.generateCountriesInternal(e,n);this.findNeighbors(r);const o=(n==null?void 0:n.minCountrySize)??1e3;if(this.mergeSmallCountries(r,o),!t||t.length===0||!t[0])throw new Error("map must be a non-empty 2D array");const s=t[0].length,l=t.length;return this.findCountryBorders(t,r,s,l),this.findNeighbors(r),{map:t,countries:r}}}function V(h){return function(){let e=h+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}function ee(h,e){return Z.generateCountries(h,{countryCount:e,minResistance:0,maxResistance:130,skipProbability:0})}const D=-1,k=-2,z=class z{constructor(e,n,t=[]){p(this,"countries");p(this,"map");p(this,"continents",[]);this.countries=t,this.map=z.createOceanMap(e,n)}static logCountryNamesInOrder(e,n=""){const t=e.map((r,o)=>`${o}: ${r.name}`);console.log(`[WorldMap] Country order${n?" - "+n:""}:
`+t.join(", "))}static checkMapCountryConsistency(e,n){if(!Array.isArray(e)||!Array.isArray(n))return console.error("[WorldMap] Consistency check failed: map or countries not arrays"),!1;let t=!0;for(let r=0;r<e.length;++r)for(let o=0;o<e[r].length;++o){const s=e[r][o];s>=0&&(n[s]?typeof n[s].name!="string"&&(console.error(`[WorldMap] Inconsistent: countries[${s}] has no valid name at map[${r}][${o}]`),t=!1):(console.error(`[WorldMap] Inconsistent: map[${r}][${o}] = ${s}, but countries[${s}] is undefined`),t=!1))}return t}assignRandomCountryNames(){let e=!1;for(;!e;){const n=new Set;for(const t of this.countries){let r,o=0;do if(r=z.generateRandomName(),o++,o>1e3)throw new Error("Failed to generate unique random country names");while(n.has(r));t.name=r,n.add(r)}e=n.size===this.countries.length}}assignRealCountryNames(){let e=!1;for(;!e;){const n=[...z.REAL_COUNTRY_NAMES],t=new Set;for(const r of this.countries){let o;if(n.length>0){const s=Math.floor(Math.random()*n.length);o=n.splice(s,1)[0]}else{let s=0;do if(o=z.generateRandomName(),s++,s>1e3)throw new Error("Failed to generate unique fallback country names");while(t.has(o))}r.name=o,t.add(o)}e=t.size===this.countries.length}}static generateRandomName(){const e=["zan","mor","vek","tal","rin","dor","lek","sha","val","nor","ka","bel","dra","sil","tur","gar","fen","mir","sol","vor","lin","sar","qu","zel","ron","bar","zen","tir","lom","kal","vin","lor","mel","dar","gol","han","jor","ken","lun","mar"],n=2+Math.floor(Math.random()*2);let t="";for(let r=0;r<n;r++)t+=e[Math.floor(Math.random()*e.length)];return t.charAt(0).toUpperCase()+t.slice(1)}static createOceanMap(e,n){return Array.from({length:n},()=>Array(e).fill(D))}static generateContinentsMap(e,n,t){return J(e,n,t)}static createMap(e,n,t=40,r=!0){const o=X(e,n),{map:s,countries:l}=ee(o,t),u=new z(e,n,l);return u.map=s,r?u.assignRealCountryNames():u.assignRandomCountryNames(),u.regenerateMapFromCountries(u.countries),u.createContinents(),u}addCountry(e){this.countries.push(e)}createContinents(){const e=new Set,n=[];for(const t of this.countries)if(!e.has(t)){const r=[t],o=[];for(e.add(t);r.length>0;){const s=r.shift();o.push(s);for(const l of s.neighbors)e.has(l)||(e.add(l),r.push(l))}n.push(new $(o))}this.continents=n}getCountries(){return this.countries}distance(e,n){const[t,r]=e.center(),[o,s]=n.center(),l=Math.sqrt((t-o)**2+(r-s)**2);if(e.neighbors.includes(n)||n.neighbors.includes(e))return l;const u=e.oceanBorder&&e.oceanBorder.length>0,g=n.oceanBorder&&n.oceanBorder.length>0;return u&&g?l*3:null}getMap(){return this.map}regenerateMapFromCountries(e){if(!this.map||!Array.isArray(this.map)||this.map.length===0||this.map[0].length===0)throw new Error("WorldMap.map is not initialized or has invalid dimensions");const n=this.map.length,t=this.map[0].length,r=z.createOceanMap(t,n);for(let o=0;o<e.length;++o){const s=e[o];if(!s.coordinates||!Array.isArray(s.coordinates))throw new Error(`Country at index ${o} has no valid coordinates array`);for(const[l,u]of s.coordinates){if(typeof l!="number"||typeof u!="number"||l<0||l>=t||u<0||u>=n)throw new Error(`Country index ${o} has out-of-bounds coordinate (${l}, ${u})`);r[u][l]=o}}this.map=r}};p(z,"REAL_COUNTRY_NAMES",["Afghanistan","Albania","Algeria","Andorra","Angola","Argentina","Armenia","Australia","Austria","Azerbaijan","Bahamas","Bahrain","Bangladesh","Barbados","Belarus","Belgium","Belize","Benin","Bhutan","Bolivia","Bosnia and Herzegovina","Botswana","Brazil","Brunei","Bulgaria","Burkina Faso","Burundi","Cabo Verde","Cambodia","Cameroon","Canada","Central African Republic","Chad","Chile","China","Colombia","Comoros","Congo","Costa Rica","Croatia","Cuba","Cyprus","Czechia","Denmark","Djibouti","Dominica","Dominican Republic","Ecuador","Egypt","El Salvador","Equatorial Guinea","Eritrea","Estonia","Eswatini","Ethiopia","Fiji","Finland","France","Gabon","Gambia","Georgia","Germany","Ghana","Greece","Grenada","Guatemala","Guinea","Guinea-Bissau","Guyana","Haiti","Honduras","Hungary","Iceland","India","Indonesia","Iran","Iraq","Ireland","Israel","Italy","Jamaica","Japan","Jordan","Kazakhstan","Kenya","Kiribati","Kuwait","Kyrgyzstan","Laos","Latvia","Lebanon","Lesotho","Liberia","Libya","Liechtenstein","Lithuania","Luxembourg","Madagascar","Malawi","Malaysia"]);let _=z;const K=self;K.onmessage=async h=>{const e=h.data;if(e.type==="generate"){const n=_.createMap(e.width,e.height,e.countryCount),t=n.getMap(),r=n.getCountries();_.checkMapCountryConsistency(t,r)||console.error("[WorldMap] Consistency check failed in worker before transfer!");const o={map:t,countries:r};K.postMessage({type:"done",result:o})}}})();
